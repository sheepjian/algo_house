#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

class HiddenNumbers {
public:
	vector <string> findAll(vector <string> text) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	HiddenNumbers *obj;
	vector <string> answer;
	obj = new HiddenNumbers();
	clock_t startTime = clock();
	answer = obj->findAll(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"098m03r9f80239802389f0m9KDKLKLJDKLJm0983m890DMOm03","dlkfj3hljf4h3klhl  4j4 444 44  rjhkrrkr34534539893"," 390804980498409480 dkldjkl djkl djkl d00000002998"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"9","44","098","444","890","0983","00000002998","34534539893","80239802389","390804980498409480"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"39 000220 30 skldjdije939939slkk 3090 2912kjdk3949","dlkjd dkljsl098 dkd3 23kdkdkl 0000002222kdjdie9000"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"0000002222","2912","3090","3949","9000","939939"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0.clear() /*{}*/;
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"0022 22k00022a022"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"0022","00022"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You are part of a data-mining operation that only cares about numbers as data.  As such, you have been assigned to write a program that gets a long chunk of text and searches for all the numbers in the text.  Because your boss cares more about large numbers, he only wants you to give him the larger half of the numbers.
// 
// You are given a vector <string> text, the lines of text to be searched for numbers, and you are to find and return the larger half of the numeric substrings in text.  Numeric substrings should never overlap, and you should always use the longest possible contiguous sequence of numbers.  For instance, "sk12345fj" has just one numeric substring - "12345".  "sk12 345fj" has 2 - "12" and "345".  If there are an odd number of numeric substrings in text, you will return (n+1)/2 strings.  These numbers should be sorted in ascending order of numeric value, and returned with any leading zeros intact.  If two numbers found in text have the same numeric value but have different numbers of leading zeros, the one with fewer leading zeros should be considered "less".  It is possible for numbers to wrap across lines - if one line ends in a number and the next one begins with a number, these are consecutive parts of the same number.
// 
// DEFINITION
// Class:HiddenNumbers
// Method:findAll
// Parameters:vector <string>
// Returns:vector <string>
// Method signature:vector <string> findAll(vector <string> text)
// 
// 
// NOTES
// -While the input will be no more than 50 elements, your return value may have more than 50 elements.
// 
// 
// CONSTRAINTS
// -text will have between 0 and 50 elements.
// -Each element in text will have between 0 and 50 characters.
// -Each element of text will contain only digits ('0'-'9'), letters ('a'-'z', 'A'-'Z'), and spaces (' ').
// -All of the numbers hidden in text will be between 0 and 263-1, but they may have leading zeros.
// 
// 
// EXAMPLES
// 
// 0)
// {"098m03r9f80239802389f0m9KDKLKLJDKLJm0983m890DMOm03",
//  "dlkfj3hljf4h3klhl  4j4 444 44  rjhkrrkr34534539893",
//  " 390804980498409480 dkldjkl djkl djkl d00000002998"}
// 
// Returns: { "9",  "44",  "098",  "444",  "890",  "0983",  "00000002998",  "34534539893",  "80239802389",  "390804980498409480" }
// 
// Most of the omitted numbers are one-digit numbers.
// 
// 1)
// {"39 000220 30 skldjdije939939slkk 3090 2912kjdk3949",
//  "dlkjd dkljsl098 dkd3 23kdkdkl 0000002222kdjdie9000"}
// 
// Returns: { "0000002222",  "2912",  "3090",  "3949",  "9000",  "939939" }
// 
// Be careful about using the length of the string to compare the numeric values - leading zeros can mess you up!
// 
// 2)
// {}
// 
// Returns: { }
// 
// This is a shorter one.
// 
// 3)
// {"0022 22k00022a022"}
// 
// Returns: { "0022",  "00022" }
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
